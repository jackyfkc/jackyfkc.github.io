How to generate unique IDs
---


## UUID

A universally unique identifier (UUID) is a 128-bit number used to identify information in computer systems. The term globally unique identifier (GUID) is also used.


* Version 1 UUIDs are generated from a time and a node id (usually the MAC address)

* Version 2 UUIDs are generated from an identifier (usually a group or user id), time, and a node id;

* Version 3 and 5 UUIDs are generated by hashing a namespace identifier and name. Version 3 uses MD5 as the hashing algorithm, and version 5 uses SHA1

* Version 4 UUIDs are generated using a random or pseudo-random number.


https://en.wikipedia.org/wiki/Universally_unique_identifier



## MongoDB ObjectId

An `ObjectId` is a 12-byte unique identifier consisting of:

   - a 4-byte value representing the seconds since the Unix epoch,
   - a 3-byte machine identifier,
   - a 2-byte process id, and
   - a 3-byte counter, starting with a random value.


Source code in [bson/objectid.py](https://github.com/py-bson/bson/blob/master/bson/objectid.py)

``` python
def __generate(self):
    """Generate a new value for this ObjectId.
    """
    # 4 bytes current time
    oid = struct.pack(">i", int(time.time()))

    # 3 bytes machine
    oid += _machine_bytes()

    # 2 bytes pid
    oid += struct.pack(">H", os.getpid() % 0xFFFF)

    # 3 bytes inc
    with ObjectId._inc_lock:
        oid += struct.pack(">i", ObjectId._inc)[1:4]
        ObjectId._inc = (ObjectId._inc + 1) % 0xFFFFFF
    self.__id = oid


def _machine_bytes():
    """Get the machine portion of an ObjectId.
    """
    machine_hash = hashlib.md5()
    if PY3:
        # gethostname() returns a unicode string in python 3.x
        # while update() requires a byte string.
        machine_hash.update(socket.gethostname().encode())
    else:
        # Calling encode() here will fail with non-ascii hostnames
        machine_hash.update(socket.gethostname())
    return machine_hash.digest()[0:3]
```

## Redis/Disque

Using a crypto hash function to generate unique IDs, used on Disque project in order to generate message IDs among multiple nodes in a distributed system.

- - -

Cryptographic hash functions are non invertible functions that transform a sequence of bits into a fixed sequence of bits. They are designed in order to resist a variety of attacks, however in this application we only rely on a given characteristic they have: uniformity of output. Changing a bit in the input of the hash function will result in each bit of the output to change with a 50% probability.

In order to have a reliable seed, we use some help from the operating system, by querying `/dev/urandom`. Seeding the generator is a moment where we really want some external entropy, otherwise we really risk of doing some huge mistake and generating the same sequence again.

As an example of crypto hash function we'll use the well known SHA1, that has an output of 160 bits. Note that you could use even MD5 sum for this application: the vulnerabilities it has have no impact in our usage here.

We start creating a seed, by reading 160 bits from `/dev/urandom`. In pseudocode it will be something like:

    seed = devurandom.read(160/8)

We also initialize a counter:

    counter = 0

Now this is the function that will generate every new ID:

    function get_new_id()
        myid = SHA1(string(counter) + seed)
        counter = counter + 1
        return myid
    end

Basically we have a fixed string, which is our seed, and we hash it with a progressive counter, so if our seed is “foo”, we output new IDs as:

    SHA1(“0foo”)
    SHA1(“1foo”)
    SHA1(“2foo”)

This is already good for our use case. However we may also need that our IDs are not easy to predict. In order to make the IDs very hard to predict instead of using `SHA1` in the `get_new_id()` function, just use `SHA1_HMAC()` instead, where the seed is the secret, and the counter the message of the `HMAC`.


http://antirez.com/news/99


## Twitter Snowflake

Snowflake is a network service for generating unique ID numbers at high scale with some simple guarantees.

Note: We should use NTP to keep our system clock accurate


https://github.com/twitter/snowflake

